# Project Euler 04
---
#### Q.   
앞에서부터 읽을 때나 뒤에서부터 읽을 때나 모양이 같은 수를 대칭수(palindrome)라고 부릅니다.

두 자리 수를 곱해 만들 수 있는 대칭수 중 가장 큰 수는 9009 (= 91 × 99) 입니다.

세 자리 수를 곱해 만들 수 있는 가장 큰 대칭수는 얼마입니까?

#### A.  
3자리 수의 곱을 통해 만들 수 있는 가장 큰 수를 찾아야 하는 문제이다.  
이 문제의 경우 최대와 최소를 생각해야 하는데 3자리 수에서 가장 작은 숫자는 100 이다. 둘을 곱했을 때 나오는 수는 10000이며, 반대로 가장 큰 숫자는 999의 제곱이다. 999의 제곱은 998001로 5자리부터 6자리 까지 결과로 발생하게 된다.  

범위를 파악한 후 프로그래밍 적으로 대칭수(palindrome)를 판별하는 것이 이 문제의 핵심이다. 여러가지 방법이 있으나 필자가 떠올린 방법은 3개이다.
* 숫자를 문자열로 바꾸어 비교하는 방법
* 나누기 연산을 통해 숫자를 뒤집어 비교하는 방법.
* 배열을 이용하는 방법

첫 번째의 경우 문제 풀이의 방법이 될 수 있으나 문제의 취지와 맞지 않으므로 풀이 방식에서 제외하였고 두 번째와 세 번째 방법이 유사하므로 그나마 구현하기 쉬운 세 번째 방법을 선택하였다.  

먼저 palindrome 을 판별할 함수 isPalindrome을 구현한다.
```c
int isPalindrome(int num)
{
  int len = 0;
  int i = 5;
  char arr[6] = {0, };

  while (num > 0)
  {
    arr[i] = num % 10;
    num /= 10;
    len++;
    i--
  }

  if (arr[5] == arr[6-len] && arr[4] == arr[7-len])
  {
    if (len == 6 && arr[3] == arr[2])
      return 1;
  }
  return 0;
}
```
코드를 간단하게 해석해보자면
```c
arr[i] = num % 10;
num /= 10;
len++;
i--;
```
현재 num의 일의 자리 숫자를 arr에 넣고 num에서 일의자리 숫자를 제거한다.
길이를 1 증가시키고 배열 인덱스의 값 1을 감소시킨다.
```c
if (arr[5] == arr[6-len] && arr[4] == arr[7-len])
{
  if (len == 6 && arr[3] == arr[2])
    return 1;
}
return 0;
```
대칭을 판단한다. 여기서 숮자가 4~5자리면 대칭수로 판단하고 1(True)을 반환한다. 두 번째 조건문에서 길이가 6이면서 대칭이기까지 하면 대칭수라는 조건을 추가하였다.  

해당 함수를 구현하였으므로 나머지 main 함수 부분도 작성한다.
```c
int main()
{
  int palindrome = 0, i, j;

  for(i = 100; i < 1000; i++){
    for(j = i; j < 1000; j++){
      if (isPalindrome(i*j) && i*j > palindrome)
        palindrome = i * j;
    }
  }
  printf("%d\n",palindrome);

  return 0;
}
```
 ##### Answer : 906609
