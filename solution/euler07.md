# Project Euler 07
---
#### Q.   
소수를 크기 순으로 나열하면 2, 3, 5, 7, 11, 13, ... 과 같이 됩니다.

이 때 10,001번째의 소수를 구하세요.

#### A.  
단순히 소수를 찾는 문제이나 방법에 따라 알고리즘의 복잡도가 달라진다.  
먼저 짝수는 2를 제외하고는 소수가 될 수 없으므로 제외한다. 짝수만 제외하더라도 전체적인 프로세스를 25% 까지 줄일 수 있다. 그리고 임의의 숫자를 i, j(반복변수) 로 나누어 가면서 j를 1씩 증가시키는데 여기서 j를 i 까지 증가시킬 필요는 없다.  

1부터 ![](https://latex.codecogs.com/gif.latex?\sqrt{i}) 까지만 i % j == 0인지 체크를 해주면 그 위의 부분은 저절로 체크가 되기 때문이다.
```c
#include <stdio.h>

int main()
{
  int i, j;
  int prime = 1;

  for(i = 3; prime < 10001; i += 2){
    if(i % 2 == 0)
      break;
    for(j = 3; j * j < i; j += 2){
      if(i % j == 0)
        break;
    }
    if(j * j > i)
      prime ++;
  }
  printf("%d\n",i - 2);
  return 0;
}
```
먼저 홀수를 제외시키기 위해 prime는 첫 번째 소수인 2를 포함해야 하기 때문에 1로 설정했다. 이후 3부터 시작하여 소수를 판별하고 횟수를 구한다. 간단한 코드 해석은 아래와 같다

* sqrt(제곱근) 대신 j*j를 사용해서 체크한다. 만약 j의 제곱이 i보다 작을 때 나누어 떨어지는 숫자가 하나도 없다면 i는 소수이다.
* 따라서 for문이 끝나면서 j += 2가 되고 if 문에서 j의 제곱이 i보다 커지기 때문에 조건문으로 이 소수가 몇 번째 소수인지 체크를 하면서 10001 번째 소수를 찾는다.
* 출력에 i-2를 한 이유는 for문을 탈출하면서 i가 2 증가하기 때문이다.

 ##### Answer : 104743
